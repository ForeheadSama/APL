import os
import re
from datetime import datetime
import requests
import json

import os
import re
from datetime import datetime
import requests
import json

class CodeGenerator:
    def __init__(self, intermediate_code_path="intermediate_code_module/intermediate_code.txt",
                 output_path="code_generator_module/generated_code.py",
                 error_path="code_generator_module/code_generator_errors.txt"):
        
        self.intermediate_code_path = intermediate_code_path
        self.output_path = output_path
        self.error_path = error_path
        self.intermediate_code = []
        self.generated_code = [] 
        self.symbol_table = {}  # Store variable names and their types
        self.error_messages = []
        self.label_counter = 0  # Counter for generating unique labels
        self.control_flow_stack = []  # Stack to manage control flow blocks
        
        # Ensure output directories exist
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        os.makedirs(os.path.dirname(error_path), exist_ok=True)

    def generate(self):
        """Main method to generate code from intermediate representation"""
        try:
            self._read_intermediate_code()
            self._generate_header()
            self._process_intermediate_code()
            self._generate_footer()
            self._write_generated_code()
            return True
        except Exception as e:
            error_msg = f"Error during code generation: {str(e)}"
            self._log_error(error_msg)
            print(error_msg)
            return False

    def _read_intermediate_code(self):
        """Read the intermediate code from file"""
        try:
            with open(self.intermediate_code_path, 'r') as f:
                self.intermediate_code = [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            raise Exception(f"Intermediate code file not found: {self.intermediate_code_path}")
        except Exception as e:
            raise Exception(f"Failed to read intermediate code: {str(e)}")

    def _generate_header(self):
        """Generate the header section of the Python code"""
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.generated_code.extend([
            "# Generated Python code",
            f"# Generated on: {current_time}",
            "# This file was automatically generated by the compiler's code generator",
            "",
            "import datetime",
            "import sys",
            "from dotenv import load_dotenv",
            "import google.generativeai as genai",
            "import json",
            "import os",
            "import re",
            "import requests",  # Add requests library for API calls
            "",
            "# Google Gemini API configuration",
            "# Make sure to set GEMINI_API_KEY as an environment variable",
            "GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')",
            "GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent'",
            "",
            "# Global variables to store tickets booking and event information",
            "events = {}",
            "bookings = {}",
            "",
            "# Helper functions for ticket system operations",
            "def fetch_events_from_gemini(event_type, date_str):",
            "    \"\"\"Use Google Gemini API to fetch information about events\"\"\"",
            "    if not GEMINI_API_KEY:",
            "        print(\"Error: GEMINI_API_KEY environment variable not set.\")",
            "        return []",
            "",
            "    headers = {",
            "        'Content-Type': 'application/json',",
            "        'x-goog-api-key': GEMINI_API_KEY",
            "    }",
            "",
            "    # Format the prompt",
            "    prompt = f\"List real {event_type} events occurring on {date_str}. \"",
            "    prompt += \"Format the response as a JSON array with each event having fields: \"",
            "    prompt += \"name, venue, time, description. Include only 5 events and be factual. \"",
            "    prompt += \"Make sure the response is valid JSON.\"",
            "",
            "    data = {",
            "        'contents': [{",
            "            'parts': [{",
            "                'text': prompt",
            "            }]",
            "        }]",
            "    }",
            "",
            "    try:",
            "        response = requests.post(",
            "            GEMINI_API_URL,",
            "            headers=headers,",
            "            json=data",
            "        )",
            "",
            "        if response.status_code == 200:",
            "            result = response.json()",
            "            text_content = result['candidates'][0]['content']['parts'][0]['text']",
            "            ",
            "            # Extract JSON from the response",
            "            try:",
            "                # First try to find JSON within triple backticks",
            "                json_match = re.search(r'```json\\n(.+?)\\n```', text_content, re.DOTALL)",
            "                if json_match:",
            "                    json_str = json_match.group(1)",
            "                else:",
            "                    # Otherwise take the whole text as JSON",
            "                    json_str = text_content",
            "                ",
            "                events_data = json.loads(json_str)",
            "                return events_data",
            "            except json.JSONDecodeError as e:",
            "                print(text_content)",
            "                return []",
            "        else:",
            "            print(f\"API request failed with status code: {response.status_code}\")",
            "            print(f\"Response: {response.text}\")",
            "            return []",
            "    except Exception as e:",
            "        print(f\"Error calling Gemini API: {str(e)}\")",
            "        return []",
            "",
            "def book_tickets(quantity, customer, date, event):",
            "    # Convert types if needed",
            "    try:",
            "        quantity = int(quantity) if not isinstance(quantity, int) else quantity",
            "    except ValueError:",
            "        print(f\"Error: Invalid quantity format. Using 1 as default.\")",
            "        quantity = 1",
            "    ",
            "    # Create event if it doesn't exist",
            "    if event not in events:",
            "        events[event] = {",
            "            'date': date,",
            "            'capacity': 100,  # Default capacity",
            "            'available_tickets': 100 - quantity,",
            "            'bookings': []",
            "        }",
            "    else:",
            "        # Update available tickets",
            "        current_available = events[event].get('available_tickets', 100)",
            "        if current_available < quantity:",
            "            print(f\"Warning: Only {current_available} tickets available for {event}\")",
            "            if current_available <= 0:",
            "                print(f\"Error: Event {event} is sold out!\")",
            "                return",
            "            quantity = current_available",
            "        events[event]['available_tickets'] = current_available - quantity",
            "    ",
            "    booking_id = f\"{customer}_{event}_{date}\"",
            "    bookings[booking_id] = {",
            "        'quantity': quantity,",
            "        'customer': customer,",
            "        'date': date,",
            "        'event': event,",
            "        'paid': False",
            "    }",
            "    # Add booking reference to the event",
            "    events[event]['bookings'].append(booking_id)",
            "    print(f\"Successfully Booked tickets for {customer} on {date} for {event}\")",
            "",
            "def list_event_details(event):",
            "    if event in events:",
            "        print(f\"Details for {event}:\")",
            "        for key, value in events[event].items():",
            "            if key != 'bookings':  # Skip printing the full bookings list",
            "                print(f\"  {key}: {value}\")",
            "        print(f\"  Total bookings: {len(events[event].get('bookings', []))}\")",
            "    else:",
            "        print(f\"Event '{event}' not found.\")",
            "        ",
            "        # Try to search for it using Gemini",
            "        try:",
            "            gemini_events = fetch_events_from_gemini(event, \"upcoming\")",
            "            ",
            "            if gemini_events:",
            "                for i, evt in enumerate(gemini_events, 1):",
            "                    if evt.get('name', '').lower() == event.lower() or event.lower() in evt.get('name', '').lower():",
            "                        print(f\"\\nFound matching event:\")",
            "                        print(f\"Name: {evt.get('name', 'Unnamed event')}\")",
            "                        print(f\"Venue: {evt.get('venue', 'Not specified')}\")",
            "                        print(f\"Time: {evt.get('time', 'Not specified')}\")",
            "                        print(f\"Description: {evt.get('description', 'No description available')}\")",
            "                        return",
            "                print(f\"No exact matches found for '{event}'\")",
            "            else:",
            "                print(\"No information found or API request failed.\")",
            "        except Exception as e:",
            "            print(f\"Error fetching event information from Gemini: {str(e)}\")",
            "",
            "def pay_for_event(event, customer):",
            "    \"\"\"Process payment for an event booking\"\"\"",
            "    booking_id = f\"{customer}_{event}_\"",
            "    found = False",
            "    for bid in bookings:",
            "        if bid.startswith(booking_id):",
            "            booking_id = bid",
            "            found = True",
            "            break",
            "",
            "    if found and booking_id in bookings:",
            "        if bookings[booking_id]['paid']:",
            "            print(f\"Booking for {customer} at {event} is already paid.\")",
            "        else:",
            "            bookings[booking_id]['paid'] = True",
            "            print(f\"Payment processed successfully for {customer} at {event}.\")",
            "    else:",
            "        print(f\"No booking found for {customer} at {event}.\")",
            "",
            "def check_availability(event, date):",
            "    \"\"\"Check ticket availability for an event\"\"\"",
            "    if event in events:",
            "        available = events[event].get('available_tickets', 0)",
            "        print(f\"There are {available} tickets available for {event} on {date}.\")",
            "    else:",
            "        print(f\"Event '{event}' not found in the system.\")",
            "        # Try to fetch from API",
            "        events_data = fetch_events_from_gemini(event, date)",
            "        if events_data:",
            "            print(\"Similar events found:\")",
            "            for e in events_data:",
            "                print(f\"- {e.get('name', 'Unknown event')} at {e.get('venue', 'Unknown venue')}\")",
            "        else:",
            "            print(\"No similar events found.\")",
            "",
            "def check_price(event, date):",
            "    \"\"\"Check ticket price for an event\"\"\"",
            "    # This is a sample implementation",
            "    price_ranges = {",
            "        \"Taylor Swift Concert\": \"$150-$450\",",
            "        \"Grand Gala\": \"$75-$200\",",
            "        \"Super Bowl\": \"$1500-$5000\",",
            "        \"Theatre Show\": \"$50-$120\",",
            "        \"Opera\": \"$85-$250\"",
            "    }",
            "    ",
            "    if event in price_ranges:",
            "        print(f\"Price range for {event} on {date}: {price_ranges[event]}\")",
            "    else:",
            "        print(f\"Price information for '{event}' not available.\")",
            "        # Try to fetch event info",
            "        events_data = fetch_events_from_gemini(event, date)",
            "        if events_data:",
            "            for e in events_data:",
            "                if e.get('name', '').lower() == event.lower():",
            "                    print(f\"Event found: {e.get('name')}\")",
            "                    # You could add price info to event data in the future",
            "                    print(\"Contact box office for pricing information.\")",
            "                    break",
            "",
            "def cancel_tickets(customer, event):",
            "    \"\"\"Cancel a booking\"\"\"",
            "    booking_prefix = f\"{customer}_{event}_\"",
            "    found_ids = [bid for bid in bookings.keys() if bid.startswith(booking_prefix)]",
            "    ",
            "    if found_ids:",
            "        for booking_id in found_ids:",
            "            # Get the quantity being canceled",
            "            qty = bookings[booking_id]['quantity']",
            "            # Add tickets back to available pool",
            "            if event in events:",
            "                events[event]['available_tickets'] += qty",
            "                # Remove booking from event's booking list",
            "                if booking_id in events[event]['bookings']:",
            "                    events[event]['bookings'].remove(booking_id)",
            "            # Remove the booking",
            "            del bookings[booking_id]",
            "        print(f\"Successfully canceled booking for {customer} at {event}.\")",
            "    else:",
            "        print(f\"No booking found for {customer} at {event}.\")",
            "",
            "# Main program starts here",
            ""
        ])

    def _process_intermediate_code(self):
        """Process each line of intermediate code and generate Python code"""
        i = 0
        while i < len(self.intermediate_code):
            line = self.intermediate_code[i]
            try:
                if line.startswith("IF NOT"):
                    self._handle_if_not(line)
                elif line.startswith("GOTO"):
                    self._handle_goto(line)
                elif line.startswith("LABEL"):
                    self._handle_label(line)
                elif line.startswith("DECLARE"):
                    self._handle_declaration(line)
                elif line.startswith("CALL"):
                    self._handle_function_call(line)
                elif line.startswith("DISPLAY"):
                    self._handle_display(line)
                elif line.startswith("ACCEPT"):
                    self._handle_input(line)
                elif "=" in line and not line.startswith(("IF", "DECLARE")):
                    self._handle_assignment(line)
                else:
                    self._log_error(f"Unknown intermediate code: {line}")
                    self.generated_code.append(f"# Unknown operation: {line}")
                i += 1
            except Exception as e:
                self._log_error(f"Error processing line '{line}': {str(e)}")
                self.generated_code.append(f"# Error processing: {line}")
                i += 1

    def _handle_if_not(self, line):
        """Handle IF NOT statements"""
        match = re.match(r"IF NOT\s+(.*)\s+GOTO\s+(L\d+)", line)
        if match:
            condition, label = match.groups()
            # Generate Python code for the if statement
            self.generated_code.append(f"if not {condition}:")
            self.generated_code.append("    " + f"# GOTO {label}")  # Indent the comment
            self.control_flow_stack.append(('if', label))
        else:
            self._log_error(f"Invalid IF NOT format: {line}")

    def _handle_goto(self, line):
        """Handle GOTO statements"""
        match = re.match(r"GOTO\s+(L\d+)", line)
        if match:
            label = match.groups()[0]
            # Generate Python code for the GOTO statement
            self.generated_code.append(f"    # GOTO {label}")  # Indent the comment
            self.control_flow_stack.append(('goto', label))
        else:
            self._log_error(f"Invalid GOTO format: {line}")

    def _handle_label(self, line):
        """Handle LABEL statements"""
        match = re.match(r"LABEL\s+(L\d+)", line)
        if match:
            label = match.groups()[0]
            # Generate Python code for the label
            self.generated_code.append(f"{label}:")  # Labels should not be indented
        else:
            self._log_error(f"Invalid LABEL format: {line}")

    def _handle_declaration(self, line):
        """Handle variable declarations"""
        match = re.match(r"DECLARE\s+(\w+)\s+AS\s+(\w+)\s+WITH VALUE\s+(.+)", line)
        if match:
            var_name, var_type, var_value = match.groups()
            self.symbol_table[var_name] = var_type.lower()

            # Generate Python code for the declaration
            if var_type.lower() == "int":
                self.generated_code.append(f"{var_name} = {var_value}  # Integer declaration")
            elif var_type.lower() == "string":
                self.generated_code.append(f"{var_name} = \"{var_value}\"  # String declaration")
            elif var_type.lower() == "date":
                self.generated_code.append(f"{var_name} = \"{var_value}\"  # Date declaration")
            else:
                self.generated_code.append(f"{var_name} = None  # {var_type} declaration")
        else:
            self._log_error(f"Invalid declaration format: {line}")

    from datetime import datetime

    def _handle_function_call(self, line):
        match = re.match(r"CALL\s+(\w+)\((.*)\)", line)
        if match:
            func_name, args_str = match.groups()
            
            # Use a more robust approach to parse arguments that may contain commas inside quotes
            processed_args = []
            
            # Parse arguments correctly while preserving quoted strings with commas
            in_quotes = False
            current_arg = ""
            i = 0
            
            while i < len(args_str):
                char = args_str[i]
                
                if char == '"' and (i == 0 or args_str[i-1] != '\\'):
                    in_quotes = not in_quotes
                    current_arg += char
                elif char == ',' and not in_quotes:
                    # End of an argument
                    processed_args.append(current_arg.strip())
                    current_arg = ""
                else:
                    current_arg += char
                
                i += 1
                    
            # Add the last argument
            if current_arg.strip():
                processed_args.append(current_arg.strip())
            
            # Process each argument
            for j in range(len(processed_args)):
                arg = processed_args[j]
                # Check if the argument is a variable or already properly formatted
                if arg in self.symbol_table or re.match(r"t\d+", arg) or re.match(r"^\d+(\.\d+)?$", arg):
                    continue  # Keep as is
                # Check if it's already a properly quoted string
                elif (arg.startswith('"') and arg.endswith('"')) or (arg.startswith("'") and arg.endswith("'")):
                    continue  # Keep as is
                else:
                    # Add quotes for string literals
                    processed_args[j] = f'"{arg}"'
            
            # Generate the function call with processed arguments
            if func_name == "list_events_on_date":
                if len(processed_args) == 2:
                    self.generated_code.append(f"events_data = fetch_events_from_gemini({processed_args[0]}, {processed_args[1]})")
                    self.generated_code.append("if events_data:")
                    self.generated_code.append("    for event in events_data:")
                    self.generated_code.append("        print(f\"Event: {event.get('name', 'Unnamed event')}\")")
                    self.generated_code.append("        print(f\"Venue: {event.get('venue', 'Not specified')}\")")
                    self.generated_code.append("        print(f\"Time: {event.get('time', 'Not specified')}\")")
                    self.generated_code.append("        print(f\"Description: {event.get('description', 'No description available')}\")")
                    self.generated_code.append("else:")
                    self.generated_code.append("    print(\"No events found for the given date.\")")
                else:
                    self._log_error(f"Invalid number of arguments for {func_name}: {len(processed_args)}")
            elif func_name == "list_event_details":
                if len(processed_args) == 1:
                    self.generated_code.append(f"list_event_details({processed_args[0]})")
                else:
                    self._log_error(f"Invalid number of arguments for {func_name}: {len(processed_args)}")
            elif func_name == "pay_for_event":
                if len(processed_args) == 2:
                    self.generated_code.append(f"pay_for_event({processed_args[0]}, {processed_args[1]})")
                else:
                    self._log_error(f"Invalid number of arguments for {func_name}: {len(processed_args)}")
            elif func_name == "check_availability":
                if len(processed_args) == 2:
                    self.generated_code.append(f"check_availability({processed_args[0]}, {processed_args[1]})")
                else:
                    self._log_error(f"Invalid number of arguments for {func_name}: {len(processed_args)}")
            elif func_name == "check_price":
                if len(processed_args) == 2:
                    self.generated_code.append(f"check_price({processed_args[0]}, {processed_args[1]})")
                else:
                    self._log_error(f"Invalid number of arguments for {func_name}: {len(processed_args)}")
            elif func_name == "cancel_tickets":
                if len(processed_args) == 2:
                    self.generated_code.append(f"cancel_tickets({processed_args[0]}, {processed_args[1]})")
                else:
                    self._log_error(f"Invalid number of arguments for {func_name}: {len(processed_args)}")
            else:
                self.generated_code.append(f"{func_name}({', '.join(processed_args)})")
        else:
            self._log_error(f"Invalid function call format: {line}")

    def _handle_display(self, line):
        """Handle display/print statements"""
        match = re.match(r"DISPLAY\s+(.*)", line)
        if match:
            message = match.groups()[0]
            self.generated_code.append(f"\nprint('{message}')")
        else:
            self._log_error(f"Invalid display format: {line}")

    def _handle_input(self, line):
        """Handle input statements"""
        match = re.match(r"ACCEPT\s+INPUT\s+INTO\s+(\w+)", line)
        if match:
            var_name = match.groups()[0]
            self.generated_code.append(f"{var_name} = input(\"Enter value for {var_name}: \")")
        else:
            self._log_error(f"Invalid input format: {line}")

    def _handle_assignment(self, line):
        """Handle assignment operations"""
        parts = line.split('=', 1)
        if len(parts) == 2:
            left, right = parts[0].strip(), parts[1].strip()
            self.generated_code.append(f"{left} = {right}")
        else:
            self._log_error(f"Invalid assignment format: {line}")

    def _generate_footer(self):
        """Generate the footer section of the Python code"""
        self.generated_code.extend([
            "",
            "# Check if API key is set",
            "if not GEMINI_API_KEY:",
            "    print(\"WARNING: GEMINI_API_KEY environment variable not set. Some functions will be limited.\")",
            "    print(\"Set it using: export GEMINI_API_KEY='your_api_key_here'\")",
            "",    
            "# End of generated code",
        ])

    def _write_generated_code(self):
        """Write the generated code to the output file"""
        try:
            with open(self.output_path, 'w') as f:
                f.write('\n'.join(self.generated_code))
            print(f"Generated code written to {self.output_path}")
        except Exception as e:
            raise Exception(f"Failed to write generated code: {str(e)}")

    def _log_error(self, message):
        """Log an error message to the error file and console"""
        self.error_messages.append(message)
        try:
            with open(self.error_path, 'a') as f:
                f.write(f"{message}\n")
        except Exception as e:
            print(f"Failed to write to error log: {str(e)}")
        print(message)